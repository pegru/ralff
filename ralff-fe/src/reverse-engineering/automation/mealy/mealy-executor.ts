import {Message, POST_MESSAGE, PRE_MESSAGE, STEP_MESSAGE, STEP_SINK_MESSAGE} from '../../socket/model/message';
import {MealyOutputCollector} from './mealy-output-collector';
import {AExecutor} from '../a-executor';
import {Validity} from '../validity';
import {RELOAD_THRESHOLD, RunConfig} from '../../run-config';
import {ACommand} from '../command/a-command';

export class MealyExecutor extends AExecutor {
  private outputCollector: MealyOutputCollector | undefined;

  constructor(commandList: ACommand[], resetCommand: ACommand) {
    super(commandList, resetCommand);
  }

  async pre(): Promise<Message | undefined> {
    const totalQueryCount = RunConfig.queryCount.eqCount + RunConfig.queryCount.mqCount;
    if (Math.floor(totalQueryCount / RELOAD_THRESHOLD) > this.thresholdMetric) {
      // refresh whole page
      window.location.reload();
      return;
    }

    this.outputCollector = new MealyOutputCollector();
    this.outputCollector.pre();
    this.resetCommand.action();
    await this.outputCollector.waitForUi();
    this.outputCollector.reset(); // discard outputs generated by reset

    this.logger.log("Reset done.");
    return PRE_MESSAGE();
  }

  async step(message: Message): Promise<Message | undefined> {
    const command = this.knownCommands.find(c => c.symbol === message.symbol);

    // prepare output collections
    this.outputCollector?.reset(); // discard previous collected outputs
    this.outputCollector?.prepare();
    const preValidityState = Validity.fromElement(command?.element);

    // perform action
    const executed = command?.action();
    if (!executed) {
      return STEP_SINK_MESSAGE();
    }

    // collect post outputs
    const outputActions = await this.outputCollector?.currentOutputs() ?? [];
    const postValidityState = Validity.fromElement(command?.element);
    const validityActions = Validity.compare(preValidityState, postValidityState);

    const actions = [...outputActions, ...validityActions];
    return STEP_MESSAGE(actions);
  }

  post(): Promise<Message | undefined> {
    this.outputCollector?.post();
    return Promise.resolve(POST_MESSAGE());
  }
}