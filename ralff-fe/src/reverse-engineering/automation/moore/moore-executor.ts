import {AExecutor} from '../a-executor';
import {Message, OUTPUT_MESSAGE, POST_MESSAGE, PRE_MESSAGE, STEP_MESSAGE, STEP_SINK_MESSAGE} from '../../socket/model/message';
import {ACommand} from '../command/a-command';
import {RELOAD_THRESHOLD, RunConfig} from '../../run-config';
import {Action, ActionProperty} from '../../utils/action-generator';
import {HTML_CONTROLS, HTML_FORM, HTML_INPUTS} from '../../utils/control-utils';
import {MooreOutputCollector} from './moore-output-collector';
import {Validity} from '../validity';

export class MooreExecutor extends AExecutor {
  private outputCollector: MooreOutputCollector | undefined;

  constructor(knownCommands: ACommand[], resetCommand: ACommand) {
    super(knownCommands, resetCommand);
  }

  extractControlAttributes(c: Element): Action[] {
    const actions: Action[] = [];
    // generate custom actions
    const ariaInvalid = c.getAttribute('aria-invalid');
    if (ariaInvalid !== null) {
      actions.push(Action.custom(ActionProperty.ARIA_INVALID, c, ariaInvalid));
    }
    const ariaDisabled = c.getAttribute('aria-disabled');
    if (ariaDisabled !== null) {
      actions.push(Action.custom(ActionProperty.ARIA_DISABLED, c, ariaDisabled));
    }
    const disabled = c.hasAttribute('disabled');
    if (disabled) {
      actions.push(Action.custom(ActionProperty.DISABLED, c, true));
    }
    if (c.matches(HTML_INPUTS)) {
      actions.push(Action.custom(ActionProperty.VALUE, c, c.getAttribute('value') ?? ''));
    }

    if (!c.hasAttribute('aria-invalid')) {
      if (c.matches(HTML_INPUTS) && c instanceof HTMLElement && Validity.fromElement(c)) {
        actions.push(...(Validity.fromElement(c)?.toStateAction() ?? []));
      }
    }

    return actions;
  }

  extractAllControlAttributes(): Action[] {
    // just consider form input controls
    const forms = document.querySelectorAll(HTML_FORM);
    if (forms.length === 0) {
      console.warn("No form detected.");
      return [];
    } else if (forms.length > 1) {
      console.warn("Detected multiple form elements. Proceeding with first form element.");
    }
    const form = forms.item(0);
    const controls = Array.from(form.querySelectorAll(HTML_CONTROLS));
    return controls.flatMap(c => this.extractControlAttributes(c));
  }

  async currentOutput(): Promise<Message> {
    const actions = this.extractAllControlAttributes();
    const additionalActions = await this.outputCollector?.currentOutputs() ?? [];
    return OUTPUT_MESSAGE([...actions, ...additionalActions]);
  }

  async pre(): Promise<Message | undefined> {
    const totalQueryCount = RunConfig.queryCount.eqCount + RunConfig.queryCount.mqCount;
    if (Math.floor(totalQueryCount / RELOAD_THRESHOLD) > this.thresholdMetric) {
      // refresh whole page
      window.location.reload();
      return;
    }

    // soft-reset
    this.outputCollector = new MooreOutputCollector();
    this.resetCommand.action();
    this.outputCollector.pre();
    this.outputCollector.reset(); // ignore outputs generated by reset

    this.logger.log("Reset done.");
    return PRE_MESSAGE();
  }

  async step(message: Message): Promise<Message | undefined> {
    const command = this.knownCommands.find(cmd => cmd.symbol === message.symbol);

    // perform action
    const executed = command?.action();
    if (!executed) {
      return STEP_SINK_MESSAGE();
    }

    // collect post outputs
    const outputActions = await this.outputCollector?.currentOutputs() ?? [];
    const controlActions = this.extractAllControlAttributes();

    // send outputs back to learner
    const actions = [...controlActions, ...outputActions]
    return STEP_MESSAGE(actions);
  }

  async post(): Promise<Message | undefined> {
    await this.outputCollector?.post();
    return POST_MESSAGE();
  }
}